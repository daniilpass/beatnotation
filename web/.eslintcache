[{"E:\\Workspace\\git\\beat\\web\\src\\index.js":"1","E:\\Workspace\\git\\beat\\web\\src\\components\\app\\App.js":"2","E:\\Workspace\\git\\beat\\web\\src\\components\\noteList\\noteList.js":"3","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\track.js":"4","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\note.js":"5","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\trackControl.js":"6"},{"size":532,"mtime":1611669435888,"results":"7","hashOfConfig":"8"},{"size":21810,"mtime":1612287044521,"results":"9","hashOfConfig":"8"},{"size":17219,"mtime":1612122923545,"results":"10","hashOfConfig":"8"},{"size":2236,"mtime":1612275264867,"results":"11","hashOfConfig":"8"},{"size":1007,"mtime":1612205469070,"results":"12","hashOfConfig":"8"},{"size":2670,"mtime":1612286023842,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"1gmhed2",{"filePath":"17","messages":"18","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"19","messages":"20","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"16"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"E:\\Workspace\\git\\beat\\web\\src\\index.js",[],["28","29"],"E:\\Workspace\\git\\beat\\web\\src\\components\\app\\App.js",["30","31"],"E:\\Workspace\\git\\beat\\web\\src\\components\\noteList\\noteList.js",["32"],"import React from \"react\";\r\n\r\nclass CanvasNotes extends React.PureComponent {\r\n    constructor(props) {\r\n      super(props);\r\n  \r\n      this.canvasWrapper = null\r\n      this.canvas = null;\r\n      this.ctx = null;\r\n      this.cWidth = 1000;\r\n      this.cHeight = 800;\r\n      // Начало по X линии\r\n      this.startX = 20;\r\n      // Линии\r\n      this.lineWidth = 2;\r\n      this.linePadding = 10;\r\n      this.linesInGroupCount = 5;      \r\n      this.lineLength = this.cWidth - this.startX*2;\r\n      // Группы линий\r\n      this.groupsCount = 5;\r\n      this.groupsPadding = 40;\r\n      // Высота группы линий\r\n      this.lineGroupHeight = this.linesInGroupCount * (this.lineWidth  + this.linePadding) + this.groupsPadding;\r\n      this.delimiterHeight = (this.linesInGroupCount + 1) * (this.lineWidth  + this.linePadding);\r\n      this.groupsPerPage = 12;\r\n      // Ноты\r\n      this.noteRadius = 5;\r\n      \r\n      this.notesInTakt = 16;\r\n      this.notesInLine = this.notesInTakt * 3;\r\n      this.taktPadding = this.noteRadius * 10;\r\n    }\r\n  \r\n    componentDidMount() { \r\n      this.canvasWrapper = document.getElementsByClassName('canvas_notes_wrapper')[0];\r\n      this.draw();\r\n      \r\n      this.lastNoteIndex = 0;\r\n    }\r\n  \r\n    initCanvasContext() {\r\n      let allCanvasElements = document.getElementsByClassName('canvas_notes')\r\n      this.canvas = allCanvasElements[allCanvasElements.length - 1];\r\n      this.ctx = this.canvas.getContext('2d');\r\n    }\r\n\r\n    draw(tracks, notesLimit, bpm) {\r\n      // Удаляю старые холсты\r\n      while (this.canvasWrapper.childElementCount > 1) {\r\n        this.canvasWrapper.removeChild(this.canvasWrapper.firstChild);\r\n      }\r\n\r\n      // Инициализирую контекст для холста\r\n      this.initCanvasContext();\r\n\r\n      this.clear();\r\n      this.drawList(tracks, notesLimit, bpm);\r\n    }\r\n    \r\n    clear() {\r\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n    \r\n    setCanvasHeight(height) {\r\n      this.canvas.height = height;\r\n    }\r\n\r\n    drawList(tracks, notesLimit, bpm) {\r\n      // Вычисляю сколько нужно строк, чтобы уместить все ноты\r\n      this.groupsCount  =  this.groupsPerPage; //Math.ceil(notesLimit / this.notesInLine);\r\n      //this.groupsCount  =  this.groupsCount > this.groupsPerPage ? this.groupsPerPage : this.groupsCount;      \r\n      // Рассчитываю высоту холста\r\n      this.cHeight = (this.groupsCount  + 1) * this.lineGroupHeight;\r\n      // Обновляю высоту холста\r\n      this.setCanvasHeight(this.cHeight);\r\n\r\n      // Рисую ифно о BPM\r\n      this.drawBpm(bpm);\r\n\r\n      // Рисую сетку\r\n      for (let i = 1; i <= this.groupsCount; i++) {\r\n        this.drawLineSet(this.startX, this.lineGroupHeight  * i);   \r\n      }\r\n  \r\n      // Рисую ноты\r\n      if (tracks) {\r\n        \r\n  \r\n        let lineNumb = 1;\r\n        let prevLineNumb = 1;\r\n        let lineNoteCounter = 1;\r\n        let taktNoteCounter = 1;\r\n        let taktCounter = 1;\r\n  \r\n        // ГРаницы для соединения нот\r\n        let downBound = Number.MAX_SAFE_INTEGER;\r\n        //let upperBound = Number.MIN_SAFE_INTEGER;\r\n        let leftBound = Number.MAX_SAFE_INTEGER;\r\n        let rightBound = Number.MIN_SAFE_INTEGER;\r\n        let pattern = [0,0,0,0];\r\n        let pattern16 = false;\r\n        let pattern4 = false;\r\n        \r\n        let notesLength = notesLimit; //tracks[0].notes.length;\r\n        for (let noteIndex = 0; noteIndex < notesLength; noteIndex++) { \r\n\r\n          // Если линий достаточно, то создаю новый canvas и рисую уже на нем\r\n          if ( (prevLineNumb !== lineNumb) && (lineNumb % this.groupsPerPage === 1) ) {\r\n            \r\n            console.log(\"NEW CANVAS\", prevLineNumb, lineNumb, this.groupsPerPage);\r\n            prevLineNumb = 1;\r\n            lineNumb = 1;\r\n            \r\n            // Создавю новый холст\r\n            let newCanvas = document.createElement(\"canvas\");\r\n            newCanvas.width = this.cWidth;\r\n            newCanvas.height = this.cHeight;\r\n            newCanvas.className =\"canvas_notes\"\r\n            this.canvasWrapper.appendChild(newCanvas);\r\n            this.initCanvasContext();\r\n\r\n            // Рисую сетку уже на новом холсте\r\n            for (let i = 1; i <= this.groupsCount; i++) {\r\n              this.drawLineSet(this.startX, this.lineGroupHeight  * i);   \r\n            }\r\n          }\r\n\r\n\r\n          // Координаты ноты по X\r\n          let note_x = this.startX + lineNoteCounter * (this.noteRadius * 2 + this.noteRadius) + taktCounter * this.taktPadding;\r\n          // Начало четверти\r\n          let lead4 = (noteIndex) % 4 === 0;\r\n          // Номер нижней ноты на линииях\r\n          let noteLine = Number.MIN_SAFE_INTEGER;\r\n          // Сбросим границы при новом такте\r\n          if (lead4) {\r\n            downBound = Number.MAX_SAFE_INTEGER;\r\n            //upperBound = Number.MIN_SAFE_INTEGER;\r\n            leftBound = Number.MAX_SAFE_INTEGER;\r\n            rightBound = Number.MIN_SAFE_INTEGER;\r\n            pattern = [0,0,0,0];\r\n            pattern16 = false;\r\n            pattern4 = false;\r\n          }\r\n  \r\n          \r\n  \r\n          // Проходим по всем треках, рисуем ноты и если начало такта, то вычисляем границы нот в такте\r\n          for (let trackIndex = 0; trackIndex <  tracks.length; trackIndex++) {\r\n            let track = tracks[trackIndex];\r\n            let note = track.notes[noteIndex];\r\n            let line = track.line;\r\n            \r\n            // Вычисление границ и размера такта\r\n            if (lead4) {\r\n              //reset bounds            \r\n              let _leftBound=Number.MAX_SAFE_INTEGER;\r\n              _leftBound = track.notes[noteIndex + 3] > 0 ? noteIndex + 3 : _leftBound; \r\n              _leftBound = track.notes[noteIndex + 2] > 0 ? noteIndex + 2 : _leftBound;\r\n              _leftBound = track.notes[noteIndex + 1] > 0 ? noteIndex + 1 : _leftBound;\r\n              _leftBound = track.notes[noteIndex] > 0 ? noteIndex : _leftBound;\r\n  \r\n              let _rightBound=Number.MIN_SAFE_INTEGER;\r\n              _rightBound = track.notes[noteIndex] > 0 ? _rightBound : _rightBound; \r\n              _rightBound = track.notes[noteIndex + 1] > 0 ? noteIndex + 1 : _rightBound;\r\n              _rightBound = track.notes[noteIndex + 2] > 0 ? noteIndex + 2 : _rightBound;\r\n              _rightBound = track.notes[noteIndex + 3] > 0 ? noteIndex +3 : _rightBound;\r\n  \r\n              leftBound = _leftBound < leftBound ? _leftBound : leftBound;\r\n              rightBound = _rightBound > rightBound ? _rightBound : rightBound;\r\n  \r\n              let _downBound = Number.MAX_SAFE_INTEGER;\r\n              _downBound = track.notes[noteIndex + 3] > 0 ? track.line : _downBound; \r\n              _downBound = track.notes[noteIndex + 2] > 0 ? track.line : _downBound;\r\n              _downBound = track.notes[noteIndex + 1] > 0 ? track.line : _downBound;\r\n              _downBound = track.notes[noteIndex] > 0     ? track.line : _downBound;\r\n              downBound = _downBound < downBound? _downBound : downBound;\r\n  \r\n              //detect size\r\n              if (track.notes[noteIndex] > 0 ) {\r\n                pattern[0]=1;\r\n              }\r\n              if (track.notes[noteIndex+1] > 0 ) {\r\n                pattern[1]=1;\r\n              }\r\n              if (track.notes[noteIndex+2] > 0 ) {\r\n                pattern[2]=1;\r\n              }\r\n              if (track.notes[noteIndex+3] > 0 ) {\r\n                pattern[3]=1;\r\n              }\r\n            }\r\n  \r\n            // Если нота звучит, то рисуем её\r\n            if (note > 0) {\r\n              let _y = lineNumb * this.lineGroupHeight - this.linePadding/2 + line * this.linePadding\r\n              this.drawNote(note_x, _y, track.type, line);\r\n  \r\n              // Запоминаем самую верхнююю линию, на которой лежит нота\r\n              noteLine = line > noteLine ? line : noteLine;\r\n            }\r\n          }\r\n          \r\n          // Нормализую границы\r\n          leftBound = leftBound !== Number.MAX_SAFE_INTEGER ? leftBound % 4 : leftBound;\r\n          rightBound = rightBound !== Number.MIN_SAFE_INTEGER ? rightBound % 4 : rightBound ;\r\n  \r\n          // Вычисляю размер        \r\n          if (lead4 && !(pattern[0] === 1 && pattern[1] === 0 && pattern[2] === 1 && pattern[3] === 0) ) {\r\n            pattern16 = true;\r\n          }\r\n          if (lead4 && (pattern[0] === 1 && pattern[1] === 0 && pattern[2] === 0 && pattern[3] === 0)) {\r\n            pattern16 = false;\r\n            pattern4 = true;\r\n          }\r\n  \r\n          //Если размер 16 и нет ноты, то рисую паузу\r\n          if (pattern16 && noteLine === Number.MIN_SAFE_INTEGER && leftBound !== Number.MAX_SAFE_INTEGER && rightBound !==Number.MIN_SAFE_INTEGER) {\r\n            let pauseLine = 3;\r\n            let x = note_x;\r\n            let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + pauseLine * this.linePadding\r\n            this.drawPause(x, y);\r\n          }\r\n  \r\n          // Подтягиваю нотные палки вверх        \r\n          if (noteLine !== Number.MIN_SAFE_INTEGER) {  \r\n              // Вертикальная линия\r\n              let x = note_x + this.noteRadius;\r\n              let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + noteLine * this.linePadding;//- this.noteRadius*2;            \r\n              let length = (noteLine - downBound ) * (this.linePadding) + this.noteRadius*6;            \r\n  \r\n              // Если размер 16 и нота не первая и не последняя в группе, то рисую палочку покороче\r\n              let idx16 = noteIndex % 4;\r\n              if (pattern16 && idx16 !== leftBound && idx16 !== rightBound) {\r\n                length  = length - this.noteRadius;\r\n              }\r\n  \r\n              this.drawVerticalLine(x, y, -length);\r\n  \r\n              // Если онты обособлены, то рисую кончик 16 нот\r\n              if (pattern16 && leftBound === rightBound) {\r\n                this.drawNote16Tail(x - this.noteRadius, y - length + this.noteRadius * 2);\r\n              }\r\n          }\r\n  \r\n          // Рисую соеденительную линию\r\n          if (lead4 && leftBound !== Number.MAX_SAFE_INTEGER && rightBound !== Number.MIN_SAFE_INTEGER) {\r\n            // Соеденительная линия размер 8\r\n            let x = note_x + this.noteRadius + leftBound* this.noteRadius * 3;\r\n            let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + downBound * this.linePadding - this.noteRadius*6;\r\n            let length = (rightBound - leftBound) * this.noteRadius * 3; \r\n            this.drawHorizontalLine(x, y, length);\r\n  \r\n            // Дополнительная соеденительная линия для размера 16\r\n            if (pattern16) {\r\n              this.drawHorizontalLine(x, y + this.noteRadius, length);\r\n            }\r\n          }\r\n  \r\n          // Разделитель тактов\r\n          if (taktNoteCounter === this.notesInTakt) { \r\n            let _x = note_x + this.taktPadding/2 + this.noteRadius * 2 - this.noteRadius/2;\r\n            let _y = lineNumb * this.lineGroupHeight - this.linePadding/2;\r\n            this.drawVerticalLine(_x, _y, this.delimiterHeight);\r\n          }\r\n  \r\n          // Считаю ноты в линии и такте\r\n          lineNoteCounter = lineNoteCounter + 1;\r\n          taktNoteCounter = taktNoteCounter + 1;\r\n  \r\n          // Если нот достаточно, то перехожу на новые строчки в листе и сбрасываю линейные счетчики\r\n          if (lineNoteCounter > this.notesInLine){\r\n            lineNoteCounter = 1;\r\n            taktCounter = 1;\r\n            taktNoteCounter = 1;  \r\n            lineNumb = lineNumb + 1;\r\n          }\r\n  \r\n          // Если такт полный, то увеличиваю счетчики такта и сбрасываю  счетчик нот в такте\r\n          if (taktNoteCounter > this.notesInTakt) {   \r\n            taktCounter = taktCounter + 1;\r\n            taktNoteCounter = 1;\r\n          }\r\n\r\n          // Для дебага рисую меньше нот\r\n          //if (lineNoteCounter > 4)        return;\r\n        }\r\n        \r\n      }\r\n    }\r\n  \r\n    // Задачет цвет и толщину\r\n    setCanvasStyle(color, width) {\r\n      this.ctx.fillStyle = color;\r\n      this.ctx.strokeStyle = color;\r\n      this.ctx.lineWidth = width;\r\n    }\r\n  \r\n    // Рисует паузу\r\n    drawPause(posX, posY) {\r\n      this.setCanvasStyle(\"#a1a1a1\", 1.1);\r\n      \r\n      let pauseRadius = this.noteRadius / 2;\r\n  \r\n      this.ctx.beginPath();\r\n      this.ctx.arc(posX + pauseRadius, posY, pauseRadius, 0, 2 * Math.PI);\r\n      this.ctx.fill();\r\n      this.ctx.arc(posX, posY + pauseRadius * 5, pauseRadius, 0, 2 * Math.PI);\r\n      this.ctx.fill();\r\n      this.ctx.moveTo(posX + pauseRadius*2, posY - pauseRadius*2);\r\n      this.ctx.lineTo(posX + pauseRadius, posY + pauseRadius * 10);    \r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    // Рисует ноту\r\n    drawNote(posX, posY, type, line) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n      if (type === 2 || type === 3) {\r\n        // X-type notes\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(posX - this.noteRadius, posY - this.noteRadius);\r\n        this.ctx.lineTo(posX + this.noteRadius, posY + this.noteRadius);\r\n        this.ctx.stroke();\r\n        this.ctx.moveTo(posX + this.noteRadius, posY - this.noteRadius);\r\n        this.ctx.lineTo(posX - this.noteRadius, posY + this.noteRadius);\r\n        this.ctx.stroke();\r\n      } else {\r\n        //  Default note\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(posX, posY, this.noteRadius, 0, 2 * Math.PI);\r\n        this.ctx.fill();\r\n      }\r\n\r\n      // Дополнительная линия для верхних ноты\r\n      if (line === 0.5) {\r\n        this.drawHorizontalLine(posX - this.noteRadius * 1.5 , posY, this.noteRadius * 3);\r\n      }\r\n      \r\n      this.drawNoteTail(posX, posY, type);\r\n    }\r\n  \r\n    // Рисует кончик для 16х нот\r\n    drawNote16Tail (posX, posY) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n      this.ctx.beginPath();      \r\n      this.ctx.moveTo(posX + this.noteRadius, posY - this.noteRadius);\r\n      this.ctx.lineTo(posX + this.noteRadius*2, posY);\r\n      this.ctx.moveTo(posX + this.noteRadius, posY - this.noteRadius * 2);\r\n      this.ctx.lineTo(posX + this.noteRadius*2, posY- this.noteRadius);\r\n      this.ctx.stroke();\r\n  \r\n    }\r\n  \r\n    // рисует особые кончики\r\n    drawNoteTail(posX, posY, type) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n       // Кружок для открытого Hi-Hat's\r\n       if (type === 3) {\r\n        // Draw o\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(posX, posY - this.noteRadius*4, this.noteRadius/2, 0, 2 * Math.PI);\r\n        this.ctx.stroke();\r\n      } \r\n    }\r\n  \r\n    // Разделитель тактов\r\n    // drawTaktDelimiter(x, y, length) {\r\n    //   this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n    //   this.ctx.beginPath();\r\n    //   this.ctx.moveTo(x, y);\r\n    //   this.ctx.lineTo(x, length);\r\n    //   this.ctx.stroke();\r\n    // }\r\n  \r\n    // Рисует группу линий\r\n    drawLineSet(startX, startY) {\r\n      for (let i = 1; i <= this.linesInGroupCount ; i++) {\r\n        this.drawHorizontalLine(startX, startY + i * this.linePadding, this.lineLength);    \r\n      }\r\n    }\r\n  \r\n    // Инфо о BPM\r\n    drawBpm(bpm) {\r\n      let oldFont = this.ctx.font;\r\n      this.ctx.font = \"16px Arial\";\r\n      this.ctx.textAlign = \"center\"\r\n      this.ctx.fillText(`BPM = ${bpm}`, this.cWidth / 2, this.groupsPadding);       \r\n      this.ctx.font = oldFont;\r\n    }\r\n\r\n    // Вертикальная линия\r\n    drawHorizontalLine(x, y, length) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(x, y);\r\n      this.ctx.lineTo(x + length, y);\r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    // Горизонтальная линия\r\n    drawVerticalLine(x, y, length) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(x, y);\r\n      this.ctx.lineTo(x, y + length);\r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    //TODO: split on different canvas for print\r\n    render() {\r\n      return <div className=\"canvas_notes_wrapper\">\r\n          <canvas className=\"canvas_notes\" width={this.cWidth} height={this.cHeight}></canvas>\r\n      </div>\r\n      \r\n        \r\n        //</div>\r\n    }\r\n}\r\n\r\n  \r\nexport default CanvasNotes;","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\track.js",[],"E:\\Workspace\\git\\beat\\web\\src\\components\\track\\note.js",[],"E:\\Workspace\\git\\beat\\web\\src\\components\\track\\trackControl.js",["33"],{"ruleId":"34","replacedBy":"35"},{"ruleId":"36","replacedBy":"37"},{"ruleId":"38","severity":1,"message":"39","line":643,"column":41,"nodeType":"40","messageId":"41","endLine":643,"endColumn":43},{"ruleId":"42","severity":1,"message":"43","line":668,"column":7,"nodeType":"44","messageId":"45","endLine":668,"endColumn":18},{"ruleId":"42","severity":1,"message":"46","line":214,"column":13,"nodeType":"44","messageId":"45","endLine":214,"endColumn":21},{"ruleId":"42","severity":1,"message":"47","line":64,"column":11,"nodeType":"44","messageId":"45","endLine":64,"endColumn":17},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'TimePointer' is defined but never used.","Identifier","unusedVar","'pattern4' is assigned a value but never used.","'deltaX' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]