[{"E:\\Workspace\\git\\beat\\web\\src\\index.js":"1","E:\\Workspace\\git\\beat\\web\\src\\components\\app\\App.js":"2","E:\\Workspace\\git\\beat\\web\\src\\components\\noteList\\noteList.js":"3","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\track.js":"4","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\note.js":"5","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\trackControl.js":"6","E:\\Workspace\\git\\beat\\web\\src\\components\\app\\TracksData.js":"7"},{"size":532,"mtime":1611669435888,"results":"8","hashOfConfig":"9"},{"size":26505,"mtime":1612470190446,"results":"10","hashOfConfig":"9"},{"size":23468,"mtime":1612451493952,"results":"11","hashOfConfig":"9"},{"size":4574,"mtime":1612468488242,"results":"12","hashOfConfig":"9"},{"size":1740,"mtime":1612467988514,"results":"13","hashOfConfig":"9"},{"size":2779,"mtime":1612372615058,"results":"14","hashOfConfig":"9"},{"size":2001,"mtime":1612372357150,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"1gmhed2",{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"21","messages":"22","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"18"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"26","usedDeprecatedRules":"18"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"18"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"E:\\Workspace\\git\\beat\\web\\src\\index.js",[],["34","35"],"E:\\Workspace\\git\\beat\\web\\src\\components\\app\\App.js",[],"E:\\Workspace\\git\\beat\\web\\src\\components\\noteList\\noteList.js",["36","37","38","39","40"],"import React from \"react\";\r\n\r\nclass CanvasNotes extends React.PureComponent {\r\n    constructor(props) {\r\n      super(props);\r\n  \r\n      this.canvasWrapper = null\r\n      this.canvas = null;\r\n      this.ctx = null;\r\n      this.cWidth = 1000;\r\n      this.cHeight = 0;\r\n      // Начало по X линии\r\n      this.startX = 20;\r\n      // Линии\r\n      this.lineWidth = 2;\r\n      this.linePadding = 10;\r\n      this.linesInGroupCount = 5;      \r\n      this.lineLength = this.cWidth - this.startX*2;\r\n      // Группы линий\r\n      this.groupsCount = 5;\r\n      this.groupsPadding = 40;\r\n      // Высота группы линий\r\n      this.lineGroupHeight = this.linesInGroupCount * (this.lineWidth  + this.linePadding) + this.groupsPadding;\r\n      this.delimiterHeight = (this.linesInGroupCount - 1) * (this.linePadding);\r\n      this.groupsPerPage = 12;\r\n      // Ноты\r\n      this.noteRadius = 5;\r\n      \r\n      this.notesInGroup = 4;\r\n      this.notesInTakt = 16;\r\n      this.notesInLine = this.notesInTakt * 4;\r\n      this.taktPadding = this.noteRadius * 5;\r\n    }\r\n  \r\n    componentDidMount() { \r\n      this.canvasWrapper = document.getElementsByClassName('canvas_notes_wrapper')[0];\r\n      //this.draw();\r\n      \r\n      this.lastNoteIndex = 0;\r\n    }\r\n  \r\n    initCanvasContext() {\r\n      let allCanvasElements = document.getElementsByClassName('canvas_notes')\r\n      this.canvas = allCanvasElements[allCanvasElements.length - 1];\r\n      this.ctx = this.canvas.getContext('2d');\r\n    }\r\n\r\n    draw(tracks, taktCountLimit, bpm, timeSignature, notesInTakt) {\r\n      // Удаляю старые холсты\r\n      while (this.canvasWrapper.childElementCount > 1) {\r\n        this.canvasWrapper.removeChild(this.canvasWrapper.firstChild);\r\n      }\r\n\r\n      // Инициализирую контекст для холста\r\n      this.initCanvasContext();\r\n\r\n      this.clear();\r\n\r\n      this.drawList(tracks, taktCountLimit, bpm, timeSignature, notesInTakt);\r\n    }\r\n    \r\n    clear() {\r\n      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n    }\r\n    \r\n    setCanvasHeight(height) {\r\n      this.canvas.height = height;\r\n    }\r\n\r\n    drawList(tracks, taktCountLimit, bpm, timeSignature, notesInTakt) {\r\n      //Размер\r\n      let tsUp =  timeSignature[0];\r\n      let tsDown = timeSignature[1];\r\n\r\n      //TODO: look at calculation in Track->Takt Component\r\n      if (tsDown === 8 && (tsUp % 3) === 0) {\r\n        this.notesInGroup = 6;\r\n      } else {\r\n        this.notesInGroup = 4;\r\n      }\r\n\r\n      this.notesInTakt = notesInTakt;\r\n\r\n      // Вычисляю сколько нужно строк, чтобы уместить все ноты\r\n      this.groupsCount  =  this.groupsPerPage; //Math.ceil(taktCountLimit / this.notesInLine);\r\n      //this.groupsCount  =  this.groupsCount > this.groupsPerPage ? this.groupsPerPage : this.groupsCount;      \r\n      // Рассчитываю высоту холста\r\n      this.cHeight = (this.groupsCount  + 1) * this.lineGroupHeight;\r\n      // Обновляю высоту холста\r\n      this.setCanvasHeight(this.cHeight);\r\n\r\n      // Рисую ифно о BPM\r\n      this.drawBpm(bpm + \". Time signature = \" + tsUp+\"/\"+tsDown);\r\n\r\n      // Рисую сетку\r\n      for (let i = 1; i <= this.groupsCount; i++) {\r\n        this.drawLineSet(this.startX, this.lineGroupHeight  * i);   \r\n      }\r\n  \r\n      // Рисую ноты\r\n      if (tracks) {\r\n        \r\n  \r\n        let lineNumb = 1;\r\n        let prevLineNumb = 1;\r\n\r\n        let lineNoteCounter = 1;\r\n        let taktCounter = 1;\r\n  \r\n        // ГРаницы для соединения нот\r\n        let downBound = Number.MAX_SAFE_INTEGER;\r\n        //let upperBound = Number.MIN_SAFE_INTEGER;\r\n        let leftBound = Number.MAX_SAFE_INTEGER;\r\n        let rightBound = Number.MIN_SAFE_INTEGER;\r\n        let pattern = [0,0,0,0];\r\n        let pattern16 = false;\r\n        let pattern8 = false;\r\n        let pattern4 = false;        \r\n      \r\n        for (let taktIndex = 0; taktIndex < taktCountLimit; taktIndex++) {\r\n\r\n          for (let noteIndex = 0; noteIndex < this.notesInTakt; noteIndex++) {\r\n            // Если линий достаточно, то создаю новый canvas и рисую уже на нем\r\n            if ( (prevLineNumb !== lineNumb) && (lineNumb % this.groupsPerPage === 1) ) {              \r\n              console.log(\"NEW CANVAS\", prevLineNumb, lineNumb, this.groupsPerPage);\r\n              prevLineNumb = 1;\r\n              lineNumb = 1;\r\n              \r\n              // Создавю новый холст\r\n              let newCanvas = document.createElement(\"canvas\");\r\n              newCanvas.width = this.cWidth;\r\n              newCanvas.height = this.cHeight;\r\n              newCanvas.className =\"canvas_notes\"\r\n              this.canvasWrapper.appendChild(newCanvas);\r\n              this.initCanvasContext();\r\n\r\n              // Рисую сетку уже на новом холсте\r\n              for (let i = 1; i <= this.groupsCount; i++) {\r\n                this.drawLineSet(this.startX, this.lineGroupHeight  * i);   \r\n              }\r\n            }\r\n\r\n            // Начало четверти\r\n            let leadNote = (noteIndex) % this.notesInGroup === 0;\r\n            // Номер нижней ноты на линииях\r\n            let noteLine = Number.MIN_SAFE_INTEGER;\r\n            // Сбросим границы при новом такте\r\n            if (leadNote) {\r\n              downBound = Number.MAX_SAFE_INTEGER;\r\n              //upperBound = Number.MIN_SAFE_INTEGER;\r\n              leftBound = Number.MAX_SAFE_INTEGER;\r\n              rightBound = Number.MIN_SAFE_INTEGER;\r\n              pattern = new Array(this.notesInGroup);\r\n              for (let i = 0; i < this.notesInGroup; i++) {\r\n                pattern[i] = 0;                \r\n              }\r\n              pattern16 = false;\r\n              pattern4 = false;\r\n            }\r\n\r\n            // Координаты ноты по X\r\n            let note_x = this.startX + lineNoteCounter * (this.noteRadius * 2.5) + taktCounter * this.taktPadding;\r\n\r\n            // Проходим по всем треках, рисуем ноты и если начало такта, то вычисляем границы нот в такте\r\n            for (let trackIndex = 0; trackIndex <  tracks.length; trackIndex++) {\r\n              let track = tracks[trackIndex];\r\n              let notes = track.takts[taktIndex].notes;\r\n              let note = notes[noteIndex];\r\n              let line = track.line;\r\n              \r\n              // Вычисление границ и размера такта\r\n              if (leadNote) {\r\n                //reset bounds            \r\n                let _leftBound=Number.MAX_SAFE_INTEGER;\r\n                for (let i = this.notesInGroup - 1; i >= 0; i--) {\r\n                  _leftBound = notes[noteIndex + i] > 0 ? noteIndex + i : _leftBound; \r\n                }\r\n                leftBound = _leftBound < leftBound ? _leftBound : leftBound;\r\n\r\n                let _rightBound=Number.MIN_SAFE_INTEGER;\r\n                for (let i = 0; i < this.notesInGroup; i++) {\r\n                  _rightBound = notes[noteIndex + i] > 0 ? noteIndex + i : _rightBound;\r\n                }                   \r\n                rightBound = _rightBound > rightBound ? _rightBound : rightBound;\r\n    \r\n                let _downBound = Number.MAX_SAFE_INTEGER;\r\n                for (let i = this.notesInGroup - 1; i >= 0; i--) {\r\n                  _downBound = notes[noteIndex + i] > 0 ? track.line : _downBound; \r\n                }\r\n                downBound = _downBound < downBound? _downBound : downBound;\r\n    \r\n                //detect size\r\n                for (let i = 0; i < this.notesInGroup; i++) {\r\n                  if (notes[noteIndex + i] > 0 ) {\r\n                    pattern[i]=1;\r\n                  }\r\n                } \r\n              }\r\n    \r\n              // Если нота звучит, то рисуем её\r\n              if (note > 0) {\r\n                let _y = lineNumb * this.lineGroupHeight - this.linePadding/2 + line * this.linePadding\r\n                this.drawNote(note_x, _y, track.type, line);\r\n    \r\n                // Запоминаем самую верхнююю линию, на которой лежит нота\r\n                noteLine = line > noteLine ? line : noteLine;\r\n              }\r\n            }\r\n            \r\n            // Нормализую границы\r\n            leftBound = leftBound !== Number.MAX_SAFE_INTEGER ? leftBound % this.notesInGroup : leftBound;\r\n            rightBound = rightBound !== Number.MIN_SAFE_INTEGER ? rightBound % this.notesInGroup : rightBound ;\r\n    \r\n            // Вычисляю размер нот в часте такта        \r\n            if (leadNote) {               \r\n              //Если ноты чередуются, то это 8й иди 16й размер\r\n              if (tsDown == 4) {\r\n                pattern16 = false;  \r\n                pattern8 = false; \r\n                for (let i = 0; i < this.notesInGroup; i=i+2) {\r\n                  if (!(pattern[i] === 1 && pattern[i+1] === 0)) {\r\n                      pattern16 =  true;               \r\n                  }\r\n                }\r\n                //Hack: четвертная нота\r\n                if ((pattern[0] === 1 && pattern[1] === 0 && pattern[2] === 0 && pattern[3] === 0)) {\r\n                  pattern16 = false;\r\n                }\r\n              }\r\n              \r\n              if (tsDown == 8) {\r\n                pattern16 = false;  \r\n                pattern8 = true; \r\n                for (let i = 0; i < this.notesInGroup; i=i+2) {\r\n                  if (!(pattern[i] === 1 && pattern[i+1] === 0) && !(pattern[i] === 0 && pattern[i+1] === 0)) {\r\n                      pattern8 = false;                \r\n                  }\r\n                }\r\n                pattern16 = (tsDown === 8 && pattern8 === false) ? true : false;\r\n              }\r\n              //console.log('pattern', pattern, 'pattern16', pattern16, 'pattern8', pattern8);\r\n            }\r\n\r\n            /*\r\n            *ПАУЗЫ\r\n            */   \r\n            \r\n            if (tsDown === 4) {\r\n              //Если четверть пустая, то рисую четвернтую паузу\r\n              if (leadNote && (pattern[0] === 0 && pattern[1] === 0 && pattern[2] === 0 && pattern[3] === 0)) {\r\n                let pauseLine = 2;\r\n                let x = note_x + this.noteRadius*4;\r\n                let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + pauseLine * this.linePadding\r\n                this.drawPause4(x,y)  \r\n              }\r\n              //Если размер 16, нет ноты и часть не пустая, то рисую паузу\r\n              if (noteLine === Number.MIN_SAFE_INTEGER && leftBound !== Number.MAX_SAFE_INTEGER && rightBound !==Number.MIN_SAFE_INTEGER) {\r\n                let pauseLine = 3;\r\n                let x = note_x;\r\n                let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + pauseLine * this.linePadding\r\n                //16-е паузы самые маленькие, вставляем на каждую пустую ноту\r\n                if (pattern16) {\r\n                  this.drawPause16(x, y);\r\n                } \r\n              }\r\n              //TODO: рисовать 8е паузы\r\n            }\r\n\r\n            if (tsDown === 8 && this.skipNote != noteIndex) {\r\n              //Если размеры такта 8, то 4я пауза на каждую 1-ю пустую ноту\r\n              if (pattern8 && noteIndex%2===0 && noteLine === Number.MIN_SAFE_INTEGER ) {              \r\n                let pauseLine = 3;\r\n                let x = note_x;\r\n                let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + pauseLine * this.linePadding\r\n                //Восьмые паузы рисуем только на 8х ноты\r\n                this.drawPause8(x, y);\r\n              } \r\n              if (pattern16 && noteLine === Number.MIN_SAFE_INTEGER) { \r\n                //console.log('====>',noteIndex, pattern, noteIndex%this.notesInGroup, noteIndex%this.notesInGroup + 1,leftBound, rightBound)\r\n                if (noteIndex%2===0 \r\n                    && pattern[noteIndex%this.notesInGroup + 1] === 0 \r\n                    && ((noteIndex%this.notesInGroup > rightBound || noteIndex%this.notesInGroup < leftBound)) ) \r\n                {\r\n                  let pauseLine = 3;\r\n                  let x = note_x;\r\n                  let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + pauseLine * this.linePadding\r\n                  //Восьмые паузы рисуем только на 8х ноты\r\n                  this.drawPause8(x, y);\r\n                  this.skipNote = noteIndex + 1;\r\n                } else {\r\n                  let pauseLine = 3;\r\n                  let x = note_x;\r\n                  let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + pauseLine * this.linePadding\r\n                  //Восьмые паузы рисуем только на 8х ноты\r\n                  this.drawPause16(x, y);\r\n                }  \r\n              }     \r\n            }\r\n\r\n            //После пропуска ноты, сбросим значение\r\n            if (this.skipNote == noteIndex) {\r\n              this.skipNote = -1;\r\n            }\r\n\r\n                   \r\n    \r\n            /*        \r\n            * Подтягиваю нотные палки вверх \r\n            */\r\n            if (noteLine !== Number.MIN_SAFE_INTEGER) {  \r\n                // Вертикальная линия\r\n                let x = note_x + this.noteRadius;\r\n                let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + noteLine * this.linePadding;//- this.noteRadius*2;            \r\n                let length = (noteLine - downBound ) * (this.linePadding) + this.noteRadius*6;            \r\n    \r\n                // Если размер 16 и нота не первая и не последняя в группе, то рисую палочку покороче\r\n                let idx16 = noteIndex % this.notesInGroup;\r\n                if (pattern16 && idx16 !== leftBound && idx16 !== rightBound) {\r\n                  length  = length - this.noteRadius;\r\n                }\r\n    \r\n                this.drawVerticalLine(x, y, -length);\r\n    \r\n                // Если ноты обособлены, то рисую кончик нот\r\n                //16\r\n                if (pattern16 && leftBound === rightBound) {\r\n                  this.drawNote16Tail(x - this.noteRadius, y - length + this.noteRadius * 2);\r\n                }\r\n                //8\r\n                if (pattern8 && leftBound === rightBound) {\r\n                  this.drawNote8Tail(x - this.noteRadius, y - length + this.noteRadius * 2);\r\n                }\r\n            }\r\n    \r\n            // Рисую соеденительную линию\r\n            if (leadNote && leftBound !== Number.MAX_SAFE_INTEGER && rightBound !== Number.MIN_SAFE_INTEGER) {\r\n              //console.log(leftBound, rightBound)\r\n              // Соеденительная линия размер 8\r\n              let x = note_x + this.noteRadius + leftBound* this.noteRadius * 2.5;\r\n              let y = lineNumb * this.lineGroupHeight - this.linePadding/2 + downBound * this.linePadding - this.noteRadius*6;\r\n              let length = (rightBound - leftBound) * this.noteRadius * 2.5; \r\n\r\n              this.drawHorizontalLine(x, y, length, 3);\r\n    \r\n              // Дополнительная соеденительная линия для размера 16\r\n              if (pattern16) {\r\n                this.drawHorizontalLine(x, y + this.noteRadius, length, 3);\r\n              }\r\n            }\r\n\r\n            // Разделитель тактов\r\n            if (noteIndex + 1 === this.notesInTakt) { \r\n              let _x = note_x + this.taktPadding/2 + this.noteRadius * 2 - this.noteRadius/2;\r\n              let _y = lineNumb * this.lineGroupHeight + this.linePadding;\r\n              this.drawVerticalLine(_x, _y, this.delimiterHeight);\r\n            }\r\n\r\n            // Считаю ноты в линии и такте\r\n            lineNoteCounter = lineNoteCounter + 1;\r\n    \r\n            // Если нот достаточно, то перехожу на новые строчки в листе и сбрасываю линейные счетчики\r\n            if (lineNoteCounter > this.notesInLine){\r\n              taktCounter = 0;\r\n              lineNoteCounter = 1;   \r\n              lineNumb = lineNumb + 1;\r\n            }\r\n          }\r\n          \r\n          taktCounter = taktCounter + 1;\r\n\r\n        }\r\n        \r\n      }\r\n    }\r\n  \r\n    // Задачет цвет и толщину\r\n    setCanvasStyle(color, width) {\r\n      this.ctx.fillStyle = color;\r\n      this.ctx.strokeStyle = color;\r\n      this.ctx.lineWidth = width;\r\n    }\r\n  \r\n    // Рисует паузу 16ю\r\n    drawPause16(posX, posY) {\r\n      this.setCanvasStyle(\"#a1a1a1\", 1.1);\r\n      \r\n      let pauseRadius = this.noteRadius / 2;\r\n  \r\n      this.ctx.beginPath();\r\n      this.ctx.arc(posX + pauseRadius, posY, pauseRadius, 0, 2 * Math.PI);\r\n      this.ctx.fill();\r\n      this.ctx.arc(posX, posY + pauseRadius * 5, pauseRadius, 0, 2 * Math.PI);\r\n      this.ctx.fill();\r\n      this.ctx.moveTo(posX + pauseRadius*2, posY - pauseRadius*2);\r\n      this.ctx.lineTo(posX + pauseRadius, posY + pauseRadius * 10);    \r\n      this.ctx.stroke();\r\n    }\r\n\r\n    // Рисует паузу 8ю\r\n    drawPause8(posX, posY) {\r\n      this.setCanvasStyle(\"#a1a1a1\", 1.1);\r\n      \r\n      let pauseRadius = this.noteRadius / 2;\r\n  \r\n      this.ctx.beginPath();\r\n      this.ctx.arc(posX + pauseRadius, posY, pauseRadius, 0, 2 * Math.PI);\r\n      this.ctx.fill();\r\n      this.ctx.moveTo(posX + pauseRadius*2, posY - pauseRadius*2);\r\n      this.ctx.lineTo(posX + pauseRadius, posY + pauseRadius * 5);    \r\n      this.ctx.stroke();\r\n    }\r\n\r\n    // Рисует паузу 4ю\r\n    drawPause4(posX, posY){\r\n      \r\n      let pauseRadius = this.noteRadius / 2;\r\n   \r\n      this.setCanvasStyle(\"#a1a1a1\", 2);\r\n      this.ctx.beginPath();     \r\n      this.ctx.moveTo(posX - pauseRadius, posY);\r\n      this.ctx.lineTo(posX + pauseRadius, posY + pauseRadius * 3);  \r\n      this.ctx.stroke();\r\n\r\n      this.setCanvasStyle(\"#a1a1a1\", 5);\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(posX + pauseRadius, posY + pauseRadius * 2.5);  \r\n      this.ctx.lineTo(posX - pauseRadius, posY + pauseRadius * 6); \r\n      this.ctx.stroke();\r\n\r\n      this.setCanvasStyle(\"#a1a1a1\", 3);\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(posX - pauseRadius, posY + pauseRadius * 6);  \r\n      this.ctx.lineTo(posX + pauseRadius, posY + pauseRadius * 9  ); \r\n      this.ctx.stroke();\r\n\r\n      this.setCanvasStyle(\"#a1a1a1\", 3);\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(posX + pauseRadius, posY + pauseRadius * 9);  \r\n      this.ctx.lineTo(posX - pauseRadius*2, posY + pauseRadius * 8); \r\n      this.ctx.stroke();\r\n\r\n      this.setCanvasStyle(\"#a1a1a1\", 3);\r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(posX - pauseRadius*2, posY + pauseRadius * 8);  \r\n      this.ctx.lineTo(posX - pauseRadius, posY + pauseRadius * 11); \r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    // Рисует ноту\r\n    drawNote(posX, posY, type, line) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n      if (type === 2 || type === 3) {\r\n        // X-type notes\r\n        this.ctx.beginPath();\r\n        this.ctx.moveTo(posX - this.noteRadius, posY - this.noteRadius);\r\n        this.ctx.lineTo(posX + this.noteRadius, posY + this.noteRadius);\r\n        this.ctx.stroke();\r\n        this.ctx.moveTo(posX + this.noteRadius, posY - this.noteRadius);\r\n        this.ctx.lineTo(posX - this.noteRadius, posY + this.noteRadius);\r\n        this.ctx.stroke();\r\n      } else {\r\n        //  Default note\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(posX, posY, this.noteRadius, 0, 2 * Math.PI);\r\n        this.ctx.fill();\r\n      }\r\n\r\n      // Дополнительная линия для верхних ноты\r\n      if (line === 0.5) {\r\n        this.drawHorizontalLine(posX - this.noteRadius * 1.5 , posY, this.noteRadius * 3);\r\n      }\r\n      \r\n      this.drawNoteTail(posX, posY, type);\r\n    }\r\n  \r\n    // Рисует кончик для 8х нот\r\n    drawNote8Tail (posX, posY) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n      this.ctx.beginPath();      \r\n      this.ctx.moveTo(posX + this.noteRadius, posY - this.noteRadius);\r\n      this.ctx.lineTo(posX + this.noteRadius*2, posY);\r\n      this.ctx.stroke();  \r\n    }\r\n\r\n    // Рисует кончик для 16х нот\r\n    drawNote16Tail (posX, posY) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n      this.ctx.beginPath();      \r\n      this.ctx.moveTo(posX + this.noteRadius, posY - this.noteRadius);\r\n      this.ctx.lineTo(posX + this.noteRadius*2, posY);\r\n      this.ctx.moveTo(posX + this.noteRadius, posY - this.noteRadius * 2);\r\n      this.ctx.lineTo(posX + this.noteRadius*2, posY- this.noteRadius);\r\n      this.ctx.stroke();  \r\n    }\r\n  \r\n    // рисует особые кончики\r\n    drawNoteTail(posX, posY, type) {\r\n      this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n       // Кружок для открытого Hi-Hat's\r\n       if (type === 3) {\r\n        // Draw o\r\n        this.ctx.beginPath();\r\n        this.ctx.arc(posX, posY - this.noteRadius*4, this.noteRadius/2, 0, 2 * Math.PI);\r\n        this.ctx.stroke();\r\n      } \r\n    }\r\n  \r\n    // Разделитель тактов\r\n    // drawTaktDelimiter(x, y, length) {\r\n    //   this.setCanvasStyle(\"#000000\", 1.1);\r\n  \r\n    //   this.ctx.beginPath();\r\n    //   this.ctx.moveTo(x, y);\r\n    //   this.ctx.lineTo(x, length);\r\n    //   this.ctx.stroke();\r\n    // }\r\n  \r\n    // Рисует группу линий\r\n    drawLineSet(startX, startY) {\r\n      for (let i = 1; i <= this.linesInGroupCount ; i++) {\r\n        this.drawHorizontalLine(startX, startY + i * this.linePadding, this.lineLength);    \r\n      }\r\n    }\r\n  \r\n    // Инфо о BPM\r\n    drawBpm(bpm) {\r\n      let oldFont = this.ctx.font;\r\n      this.ctx.font = \"16px Arial\";\r\n      this.ctx.textAlign = \"center\"\r\n      this.ctx.fillText(`BPM = ${bpm}`, this.cWidth / 2, this.groupsPadding);       \r\n      this.ctx.font = oldFont;\r\n    }\r\n\r\n    // Вертикальная линия\r\n    drawHorizontalLine(x, y, length, width) {\r\n      this.setCanvasStyle(\"#000000\", width || 1.1);\r\n  \r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(x, y);\r\n      this.ctx.lineTo(x + length, y);\r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    // Горизонтальная линия\r\n    drawVerticalLine(x, y, length, width) {\r\n      this.setCanvasStyle(\"#000000\", width || 1.1);\r\n  \r\n      this.ctx.beginPath();\r\n      this.ctx.moveTo(x, y);\r\n      this.ctx.lineTo(x, y + length);\r\n      this.ctx.stroke();\r\n    }\r\n  \r\n    //TODO: split on different canvas for print\r\n    render() {\r\n      return <div className=\"canvas_notes_wrapper\" style={this.props.style}>\r\n          <canvas className=\"canvas_notes\" width={this.cWidth} height={this.cHeight}></canvas>\r\n      </div>\r\n      \r\n        \r\n        //</div>\r\n    }\r\n}\r\n\r\n  \r\nexport default CanvasNotes;","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\track.js",["41","42"],"import React from \"react\";\r\n\r\nimport Note from \"./note\";\r\nimport TrackControl from \"./trackControl\";\r\n\r\nclass Track extends React.Component {\r\n    // constructor(props) {\r\n    //   super(props);\r\n      \r\n    // }\r\n  \r\n    shouldComponentUpdate(nextProps, nextState){\r\n      if (this.props.trackControlWidth !== nextProps.trackControlWidth\r\n        || this.props.noteHeight !== nextProps.noteHeight\r\n        || this.props.noteWidth !== nextProps.noteWidth\r\n        || this.props.tracksLengthInTakts !== nextProps.tracksLengthInTakts\r\n        || this.props.tracksLengthInNotes !== nextProps.tracksLengthInNotes\r\n        || this.props.trackControlWidth !== nextProps.trackControlWidth\r\n        || this.props.timeSignature !== nextProps.timeSignature\r\n        || this.props.style !== nextProps.style\r\n        || this.props.ts !== nextProps.ts) {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    handleNoteClick = (taktIndex, noteIndex, newlevel) => {\r\n      this.props.noteClick && this.props.noteClick(this.props.index, taktIndex, noteIndex, newlevel);\r\n    }\r\n  \r\n    get Notes() {\r\n      return this.props.track.notes;\r\n    }\r\n\r\n    onVolumeChange = (value) => {\r\n      this.props.onVolumeChange && this.props.onVolumeChange(this.props.index, value);\r\n    }\r\n\r\n    renderTakts() {\r\n      let els = [];\r\n      for (let i = 0; i < this.props.tracksLengthInTakts; i++) {\r\n        const takt = this.props.track.takts[i];\r\n        const el = <Takt key={\"takt_\"+i} noteWidth={this.props.noteWidth} noteHeight={this.props.noteHeight} \r\n          timeSignature={this.props.timeSignature}\r\n          takt={takt} index={i} tracksLengthInTakts={this.props.tracksLengthInTakts} onNoteClick={this.handleNoteClick}/>\r\n\r\n        els.push(el);\r\n      }\r\n\r\n      return els;\r\n    }\r\n  \r\n    render() {\r\n      console.log('Render Track');\r\n  \r\n      return <div className=\"workspace__track\" style={{...this.props.style, height: this.props.noteHeight, width:this.props.noteWidth * this.props.tracksLengthInNotes + this.props.trackControlWidth}}>\r\n        <TrackControl track={this.props.track} width={this.props.trackControlWidth} height={this.props.noteHeight} onVolumeChange={this.onVolumeChange} maxVolume={100}/>\r\n        {this.renderTakts()}\r\n        \r\n      </div>\r\n    }\r\n  }\r\n\r\n  export default Track;\r\n\r\nclass Takt extends React.Component {\r\n  // constructor(props) {\r\n  //   super(props)\r\n  // }\r\n\r\n  shouldComponentUpdate(nextProps, nextState) {    \r\n    if (nextProps.takt.ts !== this.props.takt.ts\r\n      || nextProps.noteWidth !== this.props.noteWidth\r\n      || nextProps.timeSignature !== this.props.timeSignature){\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  handleNoteClick = (noteIndex, newlevel) => {\r\n    this.props.onNoteClick && this.props.onNoteClick(this.props.index, noteIndex, newlevel);\r\n  }\r\n\r\n  renderNotes() {\r\n    //console.log('renderNotes', this.props.takt);\r\n    let notesInPart = 0;\r\n    let notesInGroup = 0;\r\n\r\n    let up = this.props.timeSignature[0];\r\n    let down = this.props.timeSignature[1];\r\n    switch (down) {\r\n      case 4: notesInPart = 4; break;\r\n      case 8: notesInPart = 2; break;\r\n      case 16: notesInPart = 1; break;\r\n      default:\r\n        throw (\"Unknown timeSignature:\", this.state.timeSignature);\r\n    }\r\n\r\n    if (down === 8 && (up % 3) === 0) {\r\n      notesInGroup = 6;\r\n    } else {\r\n      notesInGroup = 4;\r\n    }\r\n\r\n    //Если в тактах нечетное кол-во долей, то шахматный рисунок сбивается. Исправим\r\n    let shiftFill = false;\r\n    if (up % 2 !== 0 && this.props.index % 2 == 1) {\r\n      shiftFill = true;\r\n      console.log(\"use shift\")\r\n    }\r\n\r\n\r\n    let els = []\r\n    let notes = this.props.takt.notes;\r\n    for (let i = 0; i < notes.length; i++) {\r\n\r\n    //  let indexInQuarter = i % 16 + 1;\r\n      let filled = i % (notesInGroup*2) >= notesInGroup;\r\n      if (shiftFill) {\r\n        filled = !filled;\r\n      }\r\n      // if ((indexInQuarter >= 5 && indexInQuarter <=8) || indexInQuarter >= 13) {\r\n      //   filled = true;\r\n      // }\r\n\r\n      // console.log(i, indexInQuarter, filled);\r\n      const el = <Note key={i} index={i} filled={filled} width={this.props.noteWidth} \r\n                       noteHeight={this.props.noteHeight}\r\n                       onClick={this.handleNoteClick} level={notes[i] || 0}></Note>;\r\n      els.push(el);\r\n    }\r\n\r\n    return els;\r\n  }\r\n\r\n  render() {\r\n    //console.log('Render Takt', this.props.index);\r\n    return <div className=\"workspace__track__takt\">{this.renderNotes()}</div>\r\n  }\r\n}","E:\\Workspace\\git\\beat\\web\\src\\components\\track\\note.js",[],"E:\\Workspace\\git\\beat\\web\\src\\components\\track\\trackControl.js",["43"],"import React from \"react\";\r\n\r\nclass TrackControl extends React.Component {\r\n    constructor(props) {\r\n      super(props);  \r\n      \r\n      this.drag = {\r\n        oldClientX: -1,\r\n        oldClientY: -1\r\n      }\r\n\r\n      this.state = {\r\n        tmpVolume: -1\r\n      }\r\n\r\n      this.tcVolume = React.createRef();\r\n    }\r\n\r\n    get Title(){\r\n      return this.props.track.title;\r\n    }\r\n\r\n    get Volume() {\r\n      return Math.trunc(this.state.tmpVolume > -1 ? this.state.tmpVolume : this.props.track.volume * 100);\r\n    }\r\n\r\n    get maxVolume() {\r\n      return this.props.maxVolume || 100;\r\n    }\r\n\r\n    componentDidMount() {\r\n      this.tcVolume.current.onmousedown = this.dragMouseDown;\r\n    }\r\n\r\n    shouldComponentUpdate(prevPros, prevState) {\r\n      // console.log('shouldComponentUpdate', this.props, prevPros);\r\n      if (this.props.track.volume !== prevPros.track.volume\r\n        || this.state.tmpVolume !== prevState.tmpVolume) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    dragMouseDown = (e) => {\r\n      e.preventDefault();\r\n\r\n      this.setState({tmpVolume: this.props.track.volume * 100})\r\n      this.drag.oldClientX = e.clientX;\r\n      this.drag.oldClientY = e.clientY;\r\n\r\n      document.onmouseup = this.closeDragElement;\r\n      document.onmousemove = this.dragVolume;\r\n    }\r\n\r\n    closeDragElement = (e) => {\r\n      e.preventDefault();\r\n      document.onmouseup = null;\r\n      document.onmousemove = null;\r\n      this.props.onVolumeChange && this.props.onVolumeChange(this.state.tmpVolume / 100);\r\n      this.setState({tmpVolume: -1})\r\n    }\r\n\r\n    dragVolume = (e) => {\r\n      e.preventDefault();\r\n\r\n      //Cala delta\r\n      let deltaX = (this.drag.oldClientX - e.clientX);\r\n      let deltaY = (this.drag.oldClientY - e.clientY)\r\n      //Save new values as old\r\n      this.drag.oldClientX = e.clientX;\r\n      this.drag.oldClientY = e.clientY;\r\n      //change volume\r\n      let newVolume = this.state.tmpVolume + deltaY;\r\n      if (newVolume <= this.maxVolume && newVolume >= 0) {\r\n        window.requestAnimationFrame( () => { this.setState({tmpVolume: newVolume}) } );\r\n      }\r\n      //console.log(deltaX, deltaY, this.tmpVolume);\r\n    }\r\n\r\n    render() {  \r\n      //console.log(\"Render TrackControl\");\r\n      return <div className=\"track-control\" style={{width: this.props.width, height: this.props.height}}>\r\n          <div className=\"track-control__volume\"  ref={this.tcVolume} style={{background: `linear-gradient(to top, rgb(13 136 0 / 52%) ${this.Volume/(this.maxVolume/100)}%, transparent 0% )`}}>\r\n            {this.Volume}\r\n          </div>\r\n          <div className=\"track-control__title\" style={{lineHeight: this.props.height-2+\"px\"}}>{this.Title}</div>\r\n          \r\n      </div>\r\n    }\r\n  }\r\n\r\n  export default TrackControl;","E:\\Workspace\\git\\beat\\web\\src\\components\\app\\TracksData.js",[],{"ruleId":"44","replacedBy":"45"},{"ruleId":"46","replacedBy":"47"},{"ruleId":"48","severity":1,"message":"49","line":158,"column":15,"nodeType":"50","messageId":"51","endLine":158,"endColumn":23},{"ruleId":"52","severity":1,"message":"53","line":217,"column":26,"nodeType":"54","messageId":"55","endLine":217,"endColumn":28},{"ruleId":"52","severity":1,"message":"53","line":231,"column":26,"nodeType":"54","messageId":"55","endLine":231,"endColumn":28},{"ruleId":"52","severity":1,"message":"56","line":269,"column":47,"nodeType":"54","messageId":"55","endLine":269,"endColumn":49},{"ruleId":"52","severity":1,"message":"53","line":301,"column":31,"nodeType":"54","messageId":"55","endLine":301,"endColumn":33},{"ruleId":"48","severity":1,"message":"57","line":95,"column":16,"nodeType":"50","messageId":"51","endLine":95,"endColumn":27},{"ruleId":"52","severity":1,"message":"53","line":108,"column":46,"nodeType":"54","messageId":"55","endLine":108,"endColumn":48},{"ruleId":"48","severity":1,"message":"58","line":68,"column":11,"nodeType":"50","messageId":"51","endLine":68,"endColumn":17},"no-native-reassign",["59"],"no-negated-in-lhs",["60"],"no-unused-vars","'pattern4' is assigned a value but never used.","Identifier","unusedVar","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.","'notesInPart' is assigned a value but never used.","'deltaX' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]